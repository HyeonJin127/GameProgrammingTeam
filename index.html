<!-- =========================
 File: event.html (ë©”ì¸ HTML)
 Note: ê°™ì€ í´ë”ì— intro.css ì™€ gamelogo.png ë¥¼ ë†“ì•„ì£¼ì„¸ìš”
========================== -->
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ë˜ì „ ì˜¤ë¸Œ ë‹¤ì´ìŠ¤</title>
  <!-- ì™¸ë¶€ CSS ë¶„ë¦¬ -->
  <link rel="stylesheet" href="intro.css" />
</head>
<body>
  <!-- ìƒë‹¨ ì‚¬ìš´ë“œ í† ê¸€ ë²„íŠ¼ -->
  <div class="top-ui">
    <button id="sound" class="tiny-btn">ğŸ”Š SOUND</button>
  </div>

  <!-- ì¸íŠ¸ë¡œ ì»¨í…Œì´ë„ˆ -->
  <div class="intro" id="intro">
    <!-- ë¡œë”© ì™„ë£Œ í›„ ë“±ì¥í•  ê²Œì„ ë¡œê³  (ê°™ì€ í´ë”ì˜ gamelogo.png ë¥¼ ê°€ë¦¬í‚´) -->
    <img id="logo" src="./gamelogo.png" alt="ê²Œì„ ë¡œê³ " />

    <!-- ë¡œë”© ìƒíƒœ ë¬¸êµ¬: ë¡œë”© ì¤‘/ì™„ë£Œ ë¬¸êµ¬ê°€ ë™ì ìœ¼ë¡œ ê°±ì‹ ë¨ -->
    <div class="status" id="status">ìì›ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘â€¦</div>

    <!-- ğŸ”¥ ìš©ì•” ê²Œì´ì§€ + ì£¼ì‚¬ìœ„ í† í° ë¡œë”©ë°” -->
    <div class="dice-bar" id="diceBar" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0" aria-label="ë¡œë”© ì§„í–‰ë¥ ">
      <div class="track rock">
        <!-- ì§„í–‰ë¥  ì»¨í…Œì´ë„ˆ: width ë¡œ í¼ì„¼íŠ¸ ì œì–´ -->
        <div class="fill" id="fill">
          <!-- ìš©ì•” íë¦„/ë…¸ì´ì¦ˆ/ë²„ë¸” ë ˆì´ì–´ -->
          <div class="lava-flow"></div>
          <div class="lava-noise"></div>
          <div class="lava-bubbles" id="lavaBubbles"></div>
          <div class="lava-gloss"></div>
        </div>
      </div>

      <!-- ì§„í–‰ì„ ë”°ë¼ ì›€ì§ì´ëŠ” ì£¼ì‚¬ìœ„ í† í° -->
      <div class="token" id="token" aria-hidden="true">
        <svg class="die" viewBox="0 0 200 200" data-face="1">
          <rect x="10" y="10" width="180" height="180" rx="28" ry="28" fill="#fff" stroke="#111" stroke-width="6"></rect>
          <circle class="pip f1 f3 f5 f6" cx="50" cy="50" r="12"/>
          <circle class="pip f2 f3 f4 f5 f6" cx="150" cy="150" r="12"/>
          <circle class="pip f4 f5 f6" cx="150" cy="50" r="12"/>
          <circle class="pip f4 f5 f6" cx="50" cy="150" r="12"/>
          <circle class="pip f5" cx="100" cy="100" r="12"/>
          <circle class="pip f6" cx="50" cy="100" r="12"/>
          <circle class="pip f6" cx="150" cy="100" r="12"/>
        </svg>
        <div class="shadow" id="shadow"></div>
      </div>
    </div>
  </div>

  <!-- í´ë¦­(í„°ì¹˜) ì „í™˜ìš© íˆ¬ëª… ë² ì¼ & ê²Œì´íŠ¸ ì• ë‹ˆë©”ì´ì…˜ -->
  <div class="click-veil" id="veil" aria-hidden="true"></div>
  <div class="gate" id="gate"><div class="top"></div><div class="bottom"></div></div>

  <script>
    /* ========================
       ì¸íŠ¸ë¡œ ë¡œì§ (ë¡œë”© â†’ ì¤€ë¹„ì™„ë£Œ â†’ í´ë¦­ ì§„ì…)
       - ìš©ì•” ê²Œì´ì§€ ì§„í–‰ + ì£¼ì‚¬ìœ„ ì• ë‹ˆë©”ì´ì…˜
       - 100% ì‹œ íš¨ê³¼ìŒ + ë¡œê³  í˜ì´ë“œì¸/í™•ëŒ€
       - í™”ë©´ ì–´ë””ë“  í´ë¦­/í„°ì¹˜/Enter/Space ë¡œ ì§„ì…
    =========================*/

    // DOM ì°¸ì¡°
    const fill = document.getElementById('fill');
    const soundBtn = document.getElementById('sound');
    const statusEl = document.getElementById('status');
    const token = document.getElementById('token');
    const die = token.querySelector('.die');
    const shadow = document.getElementById('shadow');
    const logo = document.getElementById('logo');
    const diceBar = document.getElementById('diceBar');
    const veil = document.getElementById('veil');
    const gate = document.getElementById('gate');
    const intro = document.getElementById('intro');
    const bubbles = document.getElementById('lavaBubbles');

    // ì£¼ì‚¬ìœ„ ëˆˆ í‘œì‹œ í—¬í¼
    function setFace(n){
      die.querySelectorAll('.pip').forEach(el=>{
        el.style.display = el.classList.contains('f'+n) ? 'block' : 'none';
      });
    }

    // í† í°(ì£¼ì‚¬ìœ„) ìœ„ì¹˜/í”ë“¤ë¦¼ ì—…ë°ì´íŠ¸ - ë°”ì˜ ë‚´ë¶€ì—ì„œë§Œ ì´ë™
    function updateTokenPosition(percentage){
      const bw  = diceBar.clientWidth;           // ë°” ë„ˆë¹„(px)
      const tw  = token.offsetWidth || 44;       // ì£¼ì‚¬ìœ„ ë„ˆë¹„(px)
      const minCenter = tw / 2;                  // ì¢Œì¸¡ ì—¬ìœ í­
      const maxCenter = bw - tw / 2;             // ìš°ì¸¡ ì—¬ìœ í­
      const centerX = minCenter + (maxCenter - minCenter) * (percentage / 100);

      token.style.left = centerX + 'px';
      token.style.transform = `translate(-50%, -50%) rotate(${percentage*3}deg)`;

      // ê°€ë²¼ìš´ ìœ„ì•„ë˜ ë°”ìš´ìŠ¤
      const bob = Math.sin(percentage/100 * Math.PI * 2) * 6;
      token.style.transform += ` translateY(${-Math.abs(bob)}px)`;

      // ê·¸ë¦¼ì í¬ê¸°/íˆ¬ëª…ë„ ë³´ì • (ì£¼ì‚¬ìœ„ í¬ê¸°ì— ë¹„ë¡€)
      const baseShadowW = Math.max(8, Math.round(tw));
      shadow.style.width = (baseShadowW - Math.abs(bob)*0.9) + 'px';
      shadow.style.height = Math.max(8, Math.round(tw * 0.16)) + 'px';
      shadow.style.opacity = 1 - Math.abs(bob)/18;
    }

    // ìš©ì•” ë²„ë¸” ìƒì„± (ì§„í–‰ ì¤‘ì—ë§Œ ëª½ê¸€ëª½ê¸€)
    let bubbleTimer = null;
    function spawnBubble(){
      const b = document.createElement('span');
      b.className = 'bubble';
      const x = Math.random()*100; // % ê¸°ì¤€
      const s = 6 + Math.random()*10; // px
      b.style.left = x + '%';
      b.style.width = s + 'px';
      b.style.height = s + 'px';
      const dur = 1000 + Math.random()*1400;
      bubbles.appendChild(b);
      b.animate([
        { transform:'translate(-50%, 6px) scale(.8)', opacity:.0 },
        { transform:'translate(-50%, -26px) scale(1)', opacity:.9, offset:.2 },
        { transform:'translate(-50%, -58px) scale(.9)', opacity:0 }
      ], { duration: dur, easing:'cubic-bezier(.3,.8,.2,1)'});
      setTimeout(()=> b.remove(), dur+30);
    }

    // ì‚¬ìš´ë“œ ë§¤ë‹ˆì € (ê°„ë‹¨í•œ ë¹„í”„/ë¶ˆ ì†Œë¦¬)
    const AudioMgr = (()=>{
      let ctx=null, gain=null, enabled=true;
      function ensure(){
        if(!ctx){ ctx = new (window.AudioContext||window.webkitAudioContext)();
          gain = ctx.createGain(); gain.gain.value = 0.7; gain.connect(ctx.destination); }
      }
      async function resume(){ if(ctx && ctx.state==='suspended') await ctx.resume(); }
      function beep(freq=880, dur=.06){ if(!enabled) return; ensure();
        const o=ctx.createOscillator(), g=ctx.createGain(); o.type='sine'; o.frequency.value=freq;
        o.connect(g); g.connect(gain);
        g.gain.setValueAtTime(0.0001, ctx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.28, ctx.currentTime+.01);
        g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime+dur);
        o.start(); o.stop(ctx.currentTime+dur);
      }
      function fire(){ if(!enabled) return; ensure(); for(let i=0;i<5;i++){ beep(300+Math.random()*200, 0.08); } }
      function toggle(){ enabled=!enabled; beep(enabled?780:420,.05); soundBtn.textContent = enabled? 'ğŸ”Š SOUND' : 'ğŸ”‡ MUTE'; }
      return {beep, fire, toggle, resume};
    })();

    // ìƒë‹¨ ì‚¬ìš´ë“œ í† ê¸€
    soundBtn.addEventListener('click', async()=>{ await AudioMgr.resume(); AudioMgr.toggle(); });

    // ë¡œë”© ì‹œë®¬ë ˆì´ì…˜ + ì£¼ì‚¬ìœ„ ë¡¤ë§
    let load=0, ready=false, rollIndex=1; setFace(1);
    const rollTimer = setInterval(()=>{ rollIndex = (rollIndex%6)+1; setFace(rollIndex); }, 120);

    const timer = setInterval(()=>{
      load = Math.min(100, load + (load<75? Math.random()*8 : Math.random()*3 + 1));
      fill.style.width = load + '%';
      updateTokenPosition(load);

      // ì§„í–‰ ì¤‘ ë²„ë¸” í‹±
      if(!bubbleTimer){ bubbleTimer = setInterval(spawnBubble, 180); }

      if(load>35 && load<70) statusEl.textContent='ì£¼ì‚¬ìœ„ë¥¼ êµ´ë¦¬ëŠ” ì¤‘â€¦';
      if(load>=70 && load<100) statusEl.textContent='ë˜ì „ ë¬¸ì„ ì—¬ëŠ” ì¤‘â€¦';

      if(load>=100){
        clearInterval(timer); clearInterval(rollTimer); clearInterval(bubbleTimer);
        setFace(6); updateTokenPosition(100);
        AudioMgr.fire();
        // ë¡œê³  í¬ê²Œ ë“±ì¥ + ë°” ìˆ¨ê¸°ê¸° + í´ë¦­ ê°€ëŠ¥
        diceBar.classList.add('hidden');
        requestAnimationFrame(()=>{ logo.classList.add('show'); });
        statusEl.textContent='ë¡œë”© ì™„ë£Œ! í„°ì¹˜ í•´ì„œ ì ‘ì†í•˜ì„¸ìš”!';
        statusEl.classList.add('ready');
        veil.classList.add('on');
        ready = true;
      }
    }, 95);

    // ì§„ì… ì²˜ë¦¬(ê²Œì´íŠ¸ ì˜¤í”ˆ â†’ ë‹¤ìŒ í™”ë©´)
    function openGateAndEnter(){
      // ë¡œê³ /ì¸íŠ¸ë¡œê°€ ê²Œì´íŠ¸ ì• ë‹ˆë©”ì´ì…˜ ë™ì•ˆ ë³´ì´ì§€ ì•Šë„ë¡ ì¦‰ì‹œ ìˆ¨ê¹€
      veil.classList.remove('on');
      intro.style.visibility = 'hidden';
      intro.style.opacity = '0';

      // ê²Œì´íŠ¸ ì• ë‹ˆë©”ì´ì…˜ ì‹œì‘
      gate.classList.add('open');

      // ì• ë‹ˆë©”ì´ì…˜ ì™„ë£Œ í›„ ë°”ë¡œ ë‹¤ìŒ í™”ë©´ìœ¼ë¡œ ì „í™˜
      setTimeout(()=>{
        document.body.innerHTML = '<div style="display:grid;place-items:center;height:100vh;background:var(--bg);color:#fff;font-size:2.5rem;font-weight:900;">ë˜ì „ ì…ì¥!</div>';
      }, 720);
    } 720;
    
    async function tryEnter(){ if(!ready) return; await AudioMgr.resume(); AudioMgr.beep(1200,.12); openGateAndEnter(); }
    veil.addEventListener('click', tryEnter);
    intro.addEventListener('click', tryEnter);
    document.addEventListener('keydown', (e)=>{ if(ready && (e.key==='Enter' || e.key===' ')) tryEnter(); });

    // ì´í›„ë¡œëŠ” ê²Œì„ ë‚´ ë°ì´í„°ë“¤
    const ALL_EVENTS = [
        {
            id: "mystery_merchant",
            name: "ìˆ˜ìƒí•œ ìƒì¸",

            // ë“±ì¥í•˜ëŠ” ì•„ì´í…œë“¤
            itemIds: [
                { itemID: "medium_potion", weight: 70 },
                { itemID: "large_potion", weight: 20 },
                { itemID: "str_potion", weight: 10 },
            ]
        },

        {
            id: "shop",
            name: "ìƒì ",

            // ë“±ì¥í•˜ëŠ” ì•„ì´í…œë“¤
            itemIds: [ "small_potion", "medium_potion", "large_potion" ]
        },
        
        // ëª¬ìŠ¤í„° êµ¬ì¡° ì˜ˆì‹œ
        {
            id: "example",
            name: "ì˜ˆì‹œ",
            
            baseStats: {
                baseHp: 100,
                baseAttack: 100,
                baseDefense: 100,
            },

            reward: {
                goldRange: {
                    min: 1,
                    max: 1000
                },

                itemIds: [
                    { itemID: "small_potion", weight: 40 },
                    { itemID: "medium_potion", weight: 25 },
                    { itemID: "large_potion", weight: 10 },
                    { itemID: "str_potion", weight: 25 },
                ]
            }
        },

        // ëª¬ìŠ¤í„°ë“¤
        {
            id: "spider",
            name: "ê±°ë¯¸",
            
            baseStats: {
                baseHp: 10,
                baseAttack: 2,
                baseDefense: 4,
            },
            
            reward: {
                goldRange: {
                    min: 1,
                    max: 5
                },

                itemIds: [
                    { itemID: "small_potion", weight: 45 },
                    { itemID: "str_potion", weight: 5 },
                    { itemID: null, weigth: 50 },
                ]
            }
        },

        {
            id: "wolf",
            name: "ëŠ‘ëŒ€",
            
            baseStats: {
                baseHp: 10,
                baseAttack: 4,
                baseDefense: 2,
            },
            
            reward: {
                goldRange: {
                    min: 1,
                    max: 5
                },

                itemIds: [
                    { itemID: "small_potion", weight: 45 },
                    { itemID: "str_potion", weight: 5 },
                    { itemID: null, weigth: 50 },
                ]
            }
        },

        {
            id: "bear",
            name: "ê³°",
            
            baseStats: {
                baseHp: 50,
                baseAttack: 7,
                baseDefense: 9,
            },

            reward: {
                goldRange: {
                    min: 10,
                    max: 20
                },

                itemIds: [
                    { itemID: "medium_potion", weight: 40 },
                    { itemID: "str_potion", weight: 20 },
                    { itemID: null, weigth: 40 },
                ]
            }
        },

        {
            id: "head_wolf",
            name: "ìš°ë‘ë¨¸ë¦¬ ëŠ‘ëŒ€",

            baseStats: {
                baseHp: 40,
                baseAttack: 10,
                baseDefense: 5,
            },

            reward: {
                goldRange: {
                    min: 10,
                    max: 20
                },

                itemIds: [
                    { itemID: "medium_potion", weight: 40 },
                    { itemID: "str_potion", weight: 20 },
                    { itemID: null, weigth: 40 },
                ]
            }
        },
        
        {
            id: "goblin",
            name: "ê³ ë¸”ë¦°",

            baseStats: {
                baseHp: 10,
                baseAttack: 3,
                baseDefense: 3,
            },

            reward: {
                goldRange: {
                    min: 1,
                    max: 5
                },

                itemIds: [
                    { itemID: "small_potion", weight: 45 },
                    { itemID: "str_potion", weight: 5 },
                    { itemID: null, weigth: 50 },
                ]
            }
        },

        {
            id: "ork",
            name: "ì˜¤í¬",

            baseStats: {
                baseHp: 50,
                baseAttack: 8,
                baseDefense: 8,
            },

            reward: {
                goldRange: {
                    min: 10,
                    max: 20
                },

                itemIds: [
                    { itemID: "medium_potion", weight: 40 },
                    { itemID: "str_potion", weight: 30 },
                    { itemID: null, weigth: 30 },
                ]
            }
        },
    ]

    const ALL_STAGES = [
        {
            id: "forest_enter",
            name: "ìˆ² ì´ˆì…ë¶€",
            description: "",
            // ì´ë²¤íŠ¸ í™•ë¥ 
            // eventID -> ALL_EVENTS ì˜ ì´ë²¤íŠ¸ ì¤‘ í•˜ë‚˜
            // weight -> ì´ë²¤íŠ¸ê°€ ë‚˜ì˜¬ í™•ë¥  ( ê°€ì¤‘ì¹˜ )
            randomEvent: [
                { eventID: "mystery_merchant", weight: 10 },
                { eventID: "spider", weight: 45 },
                { eventID: "wolf", weight: 45 },
            ],

            nextStages: ["forest_enter", "forest_ center"],
        },

        {
            id: "forest_center",
            name: "ìˆ²ì˜ ì¤‘ì‹¬",
            description: "ì™ ì§€ ìœ„í—˜í•œ ê¸°ë¶„ì´ ë“ ë‹¤",

            randomEvent: [
                { eventID: "bear", weight: 50 },
                { eventID: "head_wolf", weight: 50 },
            ],

            nextStages: ["forest_enter", "cave_ enter"],
        },

        {
            id: "cave_enter",
            name: "ë™êµ´ ì…êµ¬",
            description: "",

            randomEvent: [
                { eventID: "mystery_merchant", weight: 10 },
                { eventID: "goblin", weight: 90 },
            ],

            nextStages: ["cave_enter", "cave_center"],
        },

        {
            id: "cave_deep",
            name: "ë™êµ´ ê¹Šì€ ê³³",
            description: "",

            randomEvent: [
                { eventID: "ork", weight: 100 },
            ],

            nextStages: ["forest_enter", "cave_ center"],
        },
    ]

    // ì•„ì´í…œ êµ¬ì¡°
    // id, name, description, type, priceRange, effect

    // id : ì•„ì´í…œ id

    // name : ì•„ì´í…œ ì´ë¦„

    // description : ì•„ì´í…œ ì„¤ëª…

    // type : ì•„ì´í…œ ë¶„ë¥˜ 
    // ( ex: consumable(ì†Œëª¨í’ˆ), weapon(ë¬´ê¸°) ë“± )

    // priceRange : ê°€ê²© ë²”ìœ„

    // effect : ì•„ì´í…œ íš¨ê³¼ 
    // - stat -> ì˜í–¥ì£¼ëŠ” ë¶€ë¶„
    // - value -> ì˜í–¥ì£¼ëŠ” ê°’
    // - direction -> íš¨ê³¼ ì ìš© ë°©í–¥
    //  - "RANDOM"     ->  + ë˜ëŠ” - ì¤‘ 50% í™•ë¥ ë¡œ ê²°ì •
    //  - "POSITIVE"   ->  í•­ìƒ +
    //  - "NEGATIVE"   ->  í•­ìƒ -
    const ALL_ITEMS = [
        {
            id: "small_potion",
            name: "ì†Œí˜• ë¬¼ì•½",
            description: "5 ~ 10 ë²”ìœ„ë‚´ hpë§Œí¼ íšŒë³µë©ë‹ˆë‹¤.",
            type: "consumable",
            priceRange: {
                minPrice: 5,
                maxPrice: 10,
            },
            effect: { 
                stat: "hp",
                value: {
                    minValue: 5,
                    maxValue: 10
                },
                
                direction: "POSITIVE"
            },
        },

        {
            id: "medium_potion",
            name: "ì¤‘í˜• ë¬¼ì•½",
            description: "15 ~ 25 ë²”ìœ„ë‚´ hpë§Œí¼ íšŒë³µë©ë‹ˆë‹¤.",
            type: "consumable",
            priceRange: {
                minPrice: 10,
                maxPrice: 15,
            },
            effect: { 
                stat: "hp",
                value: {
                    minValue: 15,
                    maxValue: 25
                },
                
                direction: "POSITIVE"
            },
        },

        {
            id: "large_potion",
            name: "ëŒ€í˜• ë¬¼ì•½",
            description: "40 ~ 50 ë²”ìœ„ë‚´ hpë§Œí¼ íšŒë³µë©ë‹ˆë‹¤.",
            type: "consumable",
            priceRange: {
                minPrice: 20,
                maxPrice: 30,
            },
            effect: { 
                stat: "hp",
                value: {
                    minValue: 40,
                    maxValue: 50
                },

                direction: "POSITIVE"
            },
        },

        {
            id: "str_potion",
            name: "ìˆ˜ìƒí•œ í˜ì˜ ë¬¼ì•½",
            description: "1 ~ 5 ë§Œí¼ í˜ ìˆ˜ì¹˜ê°€ ì˜¤ë¥´ê±°ë‚˜ ë‚´ë ¤ê°‘ë‹ˆë‹¤.",
            type: "consumable",
            priceRange: {
                minPrice: 10,
                maxPrice: 15,
            },
            effect: { 
                stat: "str",
                
                direction: "RANDOM",

                valueDrops: [
                    { amount: 1, weigth: 25 },
                    { amount: 2, weight: 40 },
                    { amount: 3, weight: 20 },
                    { amount: 4, weight: 10 },
                    { amount: 5, weigth: 5 }
                ]
            },
        },
    ]

    let player;
    let currentAreaID;
    let stageLevel;
    let currentStageData;
    let currentEvent; 
    let gameState; 
    let titleEl, statsEl, resultEl, buttonEl, inventoryButtonEl, gameContainerEl;

    let tempCombatBonus = { attack: 0, defense: 0 };

    let isATKDiceRolled = false;
    let isDEFDiceRolled = false;
    let diceRollResultLog = ""; // ì£¼ì‚¬ìœ„ êµ´ë¦¼ ê²°ê³¼ë¥¼ ëˆ„ì í•˜ì—¬ ë³´ì—¬ì¤„ ë¡œê·¸

    const STAGE_PROGRESSION_MAP = {
        'forest_enter': { nextArea: 'forest_center', levels: 4 }, // 1~4 ìŠ¤í…Œì´ì§€
        'forest_center': { nextArea: 'shop', levels: 1 },    // 5 ìŠ¤í…Œì´ì§€ (ë³´ìŠ¤)
        'shop': {nextArea: 'cave_enter', levels: 1},
        'cave_enter': { nextArea: 'cave_deep', levels: 4 },
        'cave_deep': { nextArea: 'GAME_CLEAR', levels: 1 }
    };

    function initializeDOMElements() {
        // ì¶”ê°€ëœ ë©”ì¸ ì»¨í…Œì´ë„ˆ
        gameContainerEl = document.getElementById('gameContainer');
    
        titleEl = document.getElementById('main-title');
        statsEl = document.getElementById('player-stats');
        resultEl = document.getElementById('dice-result');
        buttonEl = document.getElementById('main-button');
        inventoryButtonEl = document.getElementById('inventory-button');
    }

    function getRandomInt(min, max) {
        min = Math.ceil(min);
        max = Math.floor(max);
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function findDataById(array, id) {
        return array.find(item => item.id === id);
    }

    function getWeightedRandom(array) {
        let totalWeight = 0;
        for (const item of array) {
            totalWeight += item.weight || 0;
        }
        let randomNum = Math.random() * totalWeight;
        for (const item of array) {
            const weight = item.weight || 0;
            if (randomNum < weight) {
                return item;
            }
            randomNum -= weight;
        }
        return array[0];
    }

    // ==========================================
    // 3. UI ì—…ë°ì´íŠ¸ í•¨ìˆ˜
    // ==========================================
    function updatePlayerStatsUI() {
        if (!statsEl) return;
        const inventoryCounts = {};
        for (const itemId of player.inventory) {
            inventoryCounts[itemId] = (inventoryCounts[itemId] || 0) + 1;
        }
        let inventoryText = 'ì—†ìŒ';
        if (player.inventory.length > 0) {
            inventoryText = Object.keys(inventoryCounts).map(id => {
                const item = findDataById(ALL_ITEMS, id);
                return `${item.name} x${inventoryCounts[id]}`;
            }).join(', ');
        }

        const atkBonusText = tempCombatBonus.attack !== 0 ? `(<span style="color:${tempCombatBonus.attack > 0 ? 'yellowgreen' : 'red'};">${tempCombatBonus.attack > 0 ? '+' : ''}${tempCombatBonus.attack}</span>)` : '';
        const defBonusText = tempCombatBonus.defense !== 0 ? `(<span style="color:${tempCombatBonus.defense > 0 ? 'yellowgreen' : 'red'};">${tempCombatBonus.defense > 0 ? '+' : ''}${tempCombatBonus.defense}</span>)` : '';

        const areaInfo = STAGE_PROGRESSION_MAP[currentAreaID];
        statsEl.innerHTML = `<b>Stage: ${currentStageData.name} (${stageLevel}/${areaInfo.levels})</b><br>
                            HP: ${player.hp} / ${player.maxHp} | ATK: ${player.attack}${atkBonusText} | DEF: ${player.defense}${defBonusText} | Gold: ${player.gold}<br>
                            ì¸ë²¤í† ë¦¬: ${inventoryText}`;
    }

    function updateMainUI(title, result, buttonText) {
        if (!titleEl || !resultEl || !buttonEl) return; 
        titleEl.textContent = title;
        resultEl.innerHTML = result; 
        buttonEl.textContent = buttonText;
        resultEl.style.flexDirection = 'column';
        resultEl.style.textAlign = 'center';
    }

    function setUIForAction(showMain = false, showInventory = false) {
        if (buttonEl) buttonEl.style.display = showMain ? 'block' : 'none';
        if (inventoryButtonEl) inventoryButtonEl.style.display = showInventory ? 'block' : 'none';
    }

    // ==========================================
    // 4. ê²Œì„ í”Œë ˆì´ í•¨ìˆ˜
    // ==========================================
    function startGame() {
        player = {
            hp: 100, maxHp: 100, attack: 10, defense: 5, gold: 0, inventory: [] 
        };
        currentAreaID = 'forest_enter';
        currentStageData = findDataById(ALL_STAGES, currentAreaID);
        setMainActionListeners();
        stageLevel = 1;
        gameState = 'EXPLORING';
        updatePlayerStatsUI();
        updateMainUI(currentStageData.name, "ë¬´ì—‡ì„ í•˜ì‹œê² ìŠµë‹ˆê¹Œ?", "íƒí—˜í•˜ê¸°");
        setUIForAction(true, true); 
    }

    function handleMainAction() {
        switch (gameState) {
            case 'START':
            case 'GAME_OVER':
                startGame();
                break;
            case 'EXPLORING':
                triggerRandomEvent();
                break;
            // â­ ìˆ˜ì •: ATK ì£¼ì‚¬ìœ„ êµ´ë¦¼ ìƒíƒœ ì²˜ë¦¬ â­
            case 'DICE_ROLL_ATK':
                rollDiceATK();
                break;
            // â­ ì¶”ê°€: DEF ì£¼ì‚¬ìœ„ êµ´ë¦¼ ìƒíƒœ ì²˜ë¦¬ â­
            case 'DICE_ROLL_DEF':
                rollDiceDEF();
                break;
            case 'COMBAT':
                attackMonster();
                break;
            case 'AREA_CLEAR':
                // ... (ê¸°ì¡´ ë¡œì§ ìœ ì§€)
                break;
        }
    }

    function handleInventoryAction() {
        if (gameState === 'EXPLORING' || gameState === 'START' || gameState === 'GAME_OVER') {
            displayInventory();
        }
    }

    function triggerRandomEvent() {
        const eventRoll = getWeightedRandom(currentStageData.randomEvent); 
        const eventData = findDataById(ALL_EVENTS, eventRoll.eventID);
        if (!eventData) {
            console.error(`ì´ë²¤íŠ¸ ë°ì´í„°ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: ${eventRoll.eventID}`);
            updateMainUI(currentStageData.name, "ì•„ë¬´ê²ƒë„ ë°œê²¬í•˜ì§€ ëª»í–ˆë‹¤.", "íƒí—˜í•˜ê¸°");
            return;
        }
        if (eventData.baseStats) {
            gameState = 'DICE_ROLL'; 
            // ëª¬ìŠ¤í„° ì •ë³´ ì´ˆê¸°í™” (ì£¼ì‚¬ìœ„ êµ´ë¦¼ ì¤‘ì—ëŠ” ë³´ë„ˆìŠ¤/íŒ¨ë„í‹°ë¥¼ ë°›ì§€ ì•Šìœ¼ë¯€ë¡œ ë¦¬ì…‹)
            resetCombatDiceBonus(); 
            
            currentEvent = {
                ...eventData, 
                currentHp: eventData.baseStats.baseHp,
                attack: eventData.baseStats.baseAttack,
                defense: eventData.baseStats.baseDefense
            };
            
            displayDiceRollScreen(); // ATK ì£¼ì‚¬ìœ„ êµ´ë¦¼ í™”ë©´ í‘œì‹œ
        } 
        else if (eventData.id === "mystery_merchant" || eventData.id === "shop") {
            gameState = 'SHOPPING';
            currentEvent = { ...eventData };
            displayShopUI(); 
        }
    }

    function applyCombatDiceBonus(statType) {
        const diceRoll = getRandomInt(1, 6);
        let bonus = 0;
        const statName = statType === 'attack' ? 'ê³µê²©ë ¥(ATK)' : 'ë°©ì–´ë ¥(DEF)';
        let message = `ì£¼ì‚¬ìœ„ êµ´ë¦¼ ê²°ê³¼: ğŸ² <b>${diceRoll}</b>!`;

        if (diceRoll === 6) {
            bonus = 3;
            message += `<br>ğŸ”¥ <b>ëŒ€ì„±ê³µ!</b> ${statName} +3 ë³´ë„ˆìŠ¤!`;
        } else if (diceRoll >= 4) {
            bonus = 2;
            message += `<br>ğŸ‘ <b>ì„±ê³µ!</b> ${statName} +2 ë³´ë„ˆìŠ¤!`;
        } else if (diceRoll === 1) {
            bonus = -1;
            message += `<br>ğŸ’€ <b>ì‹¤íŒ¨...</b> ${statName} -1 íŒ¨ë„í‹°...`;
        } else {
            message += `<br>í‰ë²”í•œ êµ´ë¦¼ì…ë‹ˆë‹¤.`;
        }

        tempCombatBonus[statType] = bonus;
        return message;
    }

    function resetCombatDiceBonus() {
        // ... (ê¸°ì¡´ ë¡œì§ ìœ ì§€)
    }

    function resetCombatDiceBonus() {
        // í”Œë ˆì´ì–´ ìŠ¤íƒ¯ì—ì„œ ì„ì‹œ ë³´ë„ˆìŠ¤ ì œê±°
        player.attack -= tempCombatBonus.attack;
        player.defense -= tempCombatBonus.defense;

        // ì„ì‹œ ë³´ë„ˆìŠ¤ ì´ˆê¸°í™”
        tempCombatBonus.attack = 0;
        tempCombatBonus.defense = 0;
    }

    function displayDiceRollScreen(statType) {
        // ëª¬ìŠ¤í„° ì •ë³´ëŠ” ì´ë¯¸ currentEventì— ì €ì¥ë˜ì–´ ìˆìŒ
        const statName = statType === 'attack' ? 'ê³µê²©ë ¥(ATK)' : 'ë°©ì–´ë ¥(DEF)';
        
        updatePlayerStatsUI();
        updateMainUI(`ëª¬ìŠ¤í„° ì¶œí˜„!`, 
                    `${currentEvent.name}ì´(ê°€) ë‚˜íƒ€ë‚¬ë‹¤! ì „íˆ¬ì— ëŒì…í•˜ê¸° ì „, **${statName}** ë³´ë„ˆìŠ¤ë¥¼ ìœ„í•´ ì£¼ì‚¬ìœ„ë¥¼ êµ´ë¦½ë‹ˆë‹¤.`, 
                    `${statName} ì£¼ì‚¬ìœ„ êµ´ë¦¬ê¸°`);
        setUIForAction(true, false); 
    }

    function rollDiceATK() {
        // 1. ATK ì£¼ì‚¬ìœ„ êµ´ë¦¼ ë¡œì§ ì‹¤í–‰ ë° ê²°ê³¼ ë©”ì‹œì§€ íšë“
        const diceMessage = applyCombatDiceBonus('attack');

        // 2. ì£¼ì‚¬ìœ„ ê²°ê³¼ í™”ë©´ í‘œì‹œ
        updateMainUI(`ê³µê²©ë ¥ ì£¼ì‚¬ìœ„ ê²°ê³¼!`, 
                    `${diceMessage}<br><br><b>ë°©ì–´ë ¥ ì£¼ì‚¬ìœ„ë¥¼ êµ´ë¦´ ì¤€ë¹„ë¥¼ í•˜ì„¸ìš”.</b>`, 
                    "ë°©ì–´ë ¥ ì£¼ì‚¬ìœ„ êµ´ë¦¬ê¸°");
        
        // 3. ë‹¤ìŒ ìƒíƒœë¡œ ì „í™˜
        gameState = 'DICE_ROLL_DEF'; 
    }

    function rollDiceDEF() {
        // 1. DEF ì£¼ì‚¬ìœ„ êµ´ë¦¼ ë¡œì§ ì‹¤í–‰ ë° ê²°ê³¼ ë©”ì‹œì§€ íšë“
        const diceMessage = applyCombatDiceBonus('defense');

        // 2. ìµœì¢… ìŠ¤íƒ¯ ì ìš©
        player.attack += tempCombatBonus.attack;
        player.defense += tempCombatBonus.defense;

        // 3. ì „íˆ¬ ì‹œì‘ í™”ë©´ìœ¼ë¡œ ì „í™˜
        gameState = 'COMBAT'; 
        
        updatePlayerStatsUI(); // ìµœì¢… ìŠ¤íƒ¯ ë°˜ì˜
        updateMainUI(`ì „íˆ¬ ì‹œì‘!`, 
                    `${diceMessage}<br><br><b>${currentEvent.name}</b> (HP: ${currentEvent.currentHp})ê³¼ì˜ ì „íˆ¬ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤!`, 
                    "ê³µê²©í•˜ê¸°");
        setUIForAction(true, false);
    }

    function rollDiceAndStartCombat() {
        // 1. ì£¼ì‚¬ìœ„ ë³´ë„ˆìŠ¤ ì ìš© ë° ë©”ì‹œì§€ íšë“
        const diceMessage = applyCombatDiceBonus();

        // 2. ê²Œì„ ìƒíƒœë¥¼ ì „íˆ¬ë¡œ ë³€ê²½
        gameState = 'COMBAT';
        
        // 3. UI ì—…ë°ì´íŠ¸
        updatePlayerStatsUI(); // ë³´ë„ˆìŠ¤ ìŠ¤íƒ¯ì´ ë°˜ì˜ëœ ìŠ¤íƒ¯ì°½ ì—…ë°ì´íŠ¸
        updateMainUI(`ì „íˆ¬ ì‹œì‘!`, 
                    `${diceMessage}<br><br>${currentEvent.name} (HP: ${currentEvent.currentHp})`, 
                    "ê³µê²©í•˜ê¸°");
        setUIForAction(true, false); // ê³µê²©í•˜ê¸° ë²„íŠ¼ìœ¼ë¡œ ì „í™˜
    }

    function attackMonster() {
        let logMessage = "";
        const playerRawDamage = getRandomInt(player.attack - 2, player.attack + 2);
        const monsterDefense = currentEvent.defense;
        const playerDamage = Math.max(1, playerRawDamage - monsterDefense); 
        currentEvent.currentHp -= playerDamage;
        logMessage += `[í”Œë ˆì´ì–´] ${currentEvent.name}ì—ê²Œ ${playerDamage}ì˜ í”¼í•´! (ë°©ì–´: ${monsterDefense})`;
        if (currentEvent.currentHp <= 0) {
            winCombat(); 
            return;
        }
        const monsterRawDamage = getRandomInt(currentEvent.attack - 1, currentEvent.attack + 1);
        const playerDefense = player.defense;
        const monsterDamage = Math.max(1, monsterRawDamage - playerDefense); 
        player.hp -= monsterDamage;
        logMessage += `<br>[${currentEvent.name}] í”Œë ˆì´ì–´ì—ê²Œ ${monsterDamage}ì˜ í”¼í•´! (ë°©ì–´: ${playerDefense})`;
        if (player.hp <= 0) {
            player.hp = 0;
            loseGame();
        } else {
            updatePlayerStatsUI();
            updateMainUI('ì „íˆ¬ ì¤‘!', `${currentEvent.name} (HP: ${currentEvent.currentHp})`, "ê³µê²©í•˜ê¸°");
            resultEl.innerHTML = logMessage;
            setUIForAction(true, false); 
        }
    }

    function advanceStage() {
        // 1. í˜„ì¬ ì§€ì—­ì˜ ì§„í–‰ ì •ë³´ë¥¼ STAGE_PROGRESSION_MAPì—ì„œ ì°¾ìŠµë‹ˆë‹¤.
        const mapEntry = STAGE_PROGRESSION_MAP[currentAreaID];

        if (mapEntry) {
            // 2. ë‹¤ìŒ ì§€ì—­ IDê°€ 'GAME_CLEAR'ì¸ ê²½ìš° ê²Œì„ í´ë¦¬ì–´ ë¡œì§ ì‹¤í–‰
            if (mapEntry.nextArea === 'GAME_CLEAR') {
                winGame();
                return;
            }
            
            // 3. ë‹¤ìŒ ì§€ì—­ìœ¼ë¡œ ì´ë™
            currentAreaID = mapEntry.nextArea;
            stageLevel = 1; // ìƒˆ ì§€ì—­ì—ì„œëŠ” ë ˆë²¨ì„ 1ë¡œ ì´ˆê¸°í™”
            currentStageData = findDataById(ALL_STAGES, currentAreaID); // â­ currentStageData ì—…ë°ì´íŠ¸
            
            // 4. UIë¥¼ ì—…ë°ì´íŠ¸í•˜ê³  ë‹¤ìŒ ì§€ì—­ íƒí—˜ì„ ì¤€ë¹„í•©ë‹ˆë‹¤.
            gameState = 'EXPLORING';
            updatePlayerStatsUI();
            updateMainUI(currentStageData.name, `${currentStageData.name}ì— ì§„ì…í–ˆìŠµë‹ˆë‹¤.`, "íƒí—˜í•˜ê¸°"); 
            setUIForAction(true, true);
        }
    }

    function winCombat() {
        const reward = currentEvent.reward;
        let gainedGold = 0;
        let resultMessage = `${currentEvent.name} ì²˜ì¹˜!`;
        if (reward.goldRange) {
            gainedGold = getRandomInt(reward.goldRange.min, reward.goldRange.max);
            player.gold += gainedGold;
            resultMessage += `<br>(+${gainedGold} Gold)`;
        }
        if (reward.itemIds && reward.itemIds.length > 0) {
            const droppedItemInfo = getWeightedRandom(reward.itemIds); 
            if (droppedItemInfo && droppedItemInfo.itemID) {
                const itemData = findDataById(ALL_ITEMS, droppedItemInfo.itemID);
                if (itemData) {
                    player.inventory.push(itemData.id); 
                    resultMessage += `<br>(${itemData.name} íšë“!)`;
                }
            } else {
                resultMessage += `<br>(ì•„ì´í…œ ì—†ìŒ)`;
            }
        }

        resetCombatDiceBonus();
        
        currentEvent = null; 
        
        // ë‹¤ìŒ ì§€ì—­ìœ¼ë¡œ ì§„í–‰í•´ì•¼ í•˜ëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.
        const areaInfo = STAGE_PROGRESSION_MAP[currentAreaID];
        const nextStageLevel = stageLevel + 1; // ë‹¤ìŒ ìŠ¤í…Œì´ì§€ ë ˆë²¨ ê³„ì‚°
        
        if (nextStageLevel > areaInfo.levels) {
            // í˜„ì¬ ì§€ì—­ì˜ ëª¨ë“  ë ˆë²¨(ëª¬ìŠ¤í„°)ì„ í´ë¦¬ì–´í–ˆìŠµë‹ˆë‹¤.
            // ë‹¤ìŒ ì§€ì—­ìœ¼ë¡œ ì§„í–‰í•©ë‹ˆë‹¤.
            
            resultMessage += `<br><br><b>ğŸ‰ ì§€ì—­ í´ë¦¬ì–´! ğŸ‰</b><br>ë‹¤ìŒ ì§€ì—­ìœ¼ë¡œ ì´ë™í•©ë‹ˆë‹¤...`;
            gameState = 'AREA_CLEAR';
            
            // í˜„ì¬ ìŠ¤í…Œì´ì§€ ë ˆë²¨ì„ ìœ ì§€í•œ ì±„ë¡œ UI ì—…ë°ì´íŠ¸ (ì•„ì§ ì¦ê°€ì‹œí‚¤ì§€ ì•ŠìŒ)
            updatePlayerStatsUI();
            updateMainUI(currentStageData.name, resultMessage, "ë‹¤ìŒ ì§€ì—­ìœ¼ë¡œ");
            setUIForAction(true, false);
            
            // ë²„íŠ¼ í´ë¦­ ì´ë²¤íŠ¸ë¥¼ ì¼ì‹œì ìœ¼ë¡œ ë³€ê²½
            const originalHandler = buttonEl.onclick;
            buttonEl.onclick = () => {
                buttonEl.onclick = originalHandler; // ì›ë˜ í•¸ë“¤ëŸ¬ë¡œ ë³µêµ¬
                stageLevel++; // ì´ì œ ìŠ¤í…Œì´ì§€ ë ˆë²¨ ì¦ê°€
                advanceStage();
            };
            
            return;
        } else {
            // í˜„ì¬ ì§€ì—­ ë‚´ ë‹¤ìŒ ë ˆë²¨ë¡œ ì§„í–‰í•©ë‹ˆë‹¤.
            stageLevel++; // ì—¬ê¸°ì„œ ìŠ¤í…Œì´ì§€ ë ˆë²¨ ì¦ê°€
            resultMessage += `<br><br>ë‹¤ìŒ ìŠ¤í…Œì´ì§€ (${stageLevel}/${areaInfo.levels}) ë¡œ ì´ë™í•©ë‹ˆë‹¤.`;
            gameState = 'EXPLORING';
        }
        
        updatePlayerStatsUI();
        updateMainUI(currentStageData.name, resultMessage, "íƒí—˜í•˜ê¸°");
        setUIForAction(true, true); 
    }

    function loseGame() {
        resetCombatDiceBonus();

        gameState = 'GAME_OVER';
        updatePlayerStatsUI();
        updateMainUI("ê²Œì„ ì˜¤ë²„", "ì‚¬ë§í–ˆìŠµë‹ˆë‹¤...", "ë‹¤ì‹œ ì‹œì‘í•˜ê¸°");
        setUIForAction(true, true); 
    }

    function winGame() {
        gameState = 'GAME_OVER'; 
        updatePlayerStatsUI();
        updateMainUI("â˜… GAME CLEAR â˜…", "ëª¨ë“  ìŠ¤í…Œì´ì§€ë¥¼ í´ë¦¬ì–´í–ˆìŠµë‹ˆë‹¤!", "ë‹¤ì‹œ ì‹œì‘í•˜ê¸°");
        setUIForAction(true, false); 
    }

    function setMainActionListeners() {
        // ì¼ë°˜ ìƒíƒœ: ë©”ì¸ ë²„íŠ¼ = handleMainAction, ì¸ë²¤í† ë¦¬ ë²„íŠ¼ = handleInventoryAction
        buttonEl.onclick = handleMainAction;
        inventoryButtonEl.onclick = handleInventoryAction;
    }

    function clearMainActionListeners() {
        // ë¦¬ìŠ¤ë„ˆ ì œê±°
        buttonEl.onclick = null;
        inventoryButtonEl.onclick = null;
    }

    function setDiceRollListeners() {
        // ì£¼ì‚¬ìœ„ êµ´ë¦¼ ìƒíƒœ: ë©”ì¸ ë²„íŠ¼ = ATK êµ´ë¦¼, ì¸ë²¤í† ë¦¬ ë²„íŠ¼ = DEF êµ´ë¦¼
        clearMainActionListeners();
        buttonEl.onclick = handleATKDiceRoll;
        inventoryButtonEl.onclick = handleDEFDiceRoll;
    }

    // [4. ê²Œì„ í”Œë ˆì´ í•¨ìˆ˜] ì„¹ì…˜ì— ìƒˆë¡œ ì¶”ê°€

    function displayDiceRollScreen() {
        // ìƒíƒœ ì´ˆê¸°í™”
        isATKDiceRolled = false;
        isDEFDiceRolled = false;
        diceRollResultLog = "";
        
        // ë²„íŠ¼ ë¦¬ìŠ¤ë„ˆ ì„¤ì •
        setDiceRollListeners();

        // UI ì—…ë°ì´íŠ¸
        updatePlayerStatsUI();
        updateMainUI(`ëª¬ìŠ¤í„° ì¶œí˜„!`, 
                    `${currentEvent.name}ì´(ê°€) ë‚˜íƒ€ë‚¬ë‹¤! ì „íˆ¬ì— ëŒì…í•˜ê¸° ì „, ê³µê²©ë ¥ê³¼ ë°©ì–´ë ¥ ì£¼ì‚¬ìœ„ë¥¼ êµ´ë¦½ë‹ˆë‹¤.`, 
                    "ê³µê²©ë ¥ ì£¼ì‚¬ìœ„ êµ´ë¦¬ê¸°");
        
        // ì¸ë²¤í† ë¦¬ ë²„íŠ¼ì„ DEF ì£¼ì‚¬ìœ„ ë²„íŠ¼ìœ¼ë¡œ ì‚¬ìš©
        inventoryButtonEl.textContent = 'ë°©ì–´ë ¥ ì£¼ì‚¬ìœ„ êµ´ë¦¬ê¸°';
        inventoryButtonEl.disabled = false; // ë²„íŠ¼ í™œì„±í™”
        buttonEl.disabled = false;
        setUIForAction(true, true); // ë‘ ë²„íŠ¼ ëª¨ë‘ í‘œì‹œ
    }

    function startCombatAfterDiceRoll() {
        // 1. ìµœì¢… ìŠ¤íƒ¯ ì ìš©
        player.attack += tempCombatBonus.attack;
        player.defense += tempCombatBonus.defense;

        // 2. ì „íˆ¬ ìƒíƒœë¡œ ì „í™˜ ë° ë¦¬ìŠ¤ë„ˆ ë³µêµ¬
        gameState = 'COMBAT'; 
        setMainActionListeners(); 

        buttonEl.disabled = false;
        inventoryButtonEl.disabled = false;
        inventoryButtonEl.textContent = 'ì¸ë²¤í† ë¦¬';

        // 3. UI ì—…ë°ì´íŠ¸
        updatePlayerStatsUI(); 
        updateMainUI(`ì „íˆ¬ ì‹œì‘!`, 
                    `${diceRollResultLog}<br><b>${currentEvent.name}</b> (HP: ${currentEvent.currentHp})ê³¼ì˜ ì „íˆ¬ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤!`, 
                    "ê³µê²©í•˜ê¸°");
        setUIForAction(true, false); // ì¸ë²¤í† ë¦¬ ë²„íŠ¼ ìˆ¨ê¹€ (ì›ë˜ì˜ ì „íˆ¬ UI)
    }

    function handleATKDiceRoll() {
        if (isATKDiceRolled) return;

        const message = applyCombatDiceBonus('attack');

        isATKDiceRolled = true;
        diceRollResultLog += `[ATK êµ´ë¦¼]: ${message}<br>`;

        buttonEl.disabled = true;
        buttonEl.textContent = `ê³µê²©ë ¥ êµ´ë¦¼ ì™„ë£Œ (+${tempCombatBonus.attack})`;

        resultEl.innerHTML = diceRollResultLog;
        updatePlayerStatsUI();
        
        // ë‘ ì£¼ì‚¬ìœ„ ëª¨ë‘ êµ´ë ¸ìœ¼ë©´ ì „íˆ¬ ì‹œì‘
        if (isDEFDiceRolled) {
            startCombatAfterDiceRoll();
        }
    }

    function handleDEFDiceRoll() {
        if (isDEFDiceRolled) return;

        const message = applyCombatDiceBonus('defense');

        isDEFDiceRolled = true;
        diceRollResultLog += `[DEF êµ´ë¦¼]: ${message}<br>`;

        inventoryButtonEl.disabled = true;
        inventoryButtonEl.textContent = `ë°©ì–´ë ¥ êµ´ë¦¼ ì™„ë£Œ (+${tempCombatBonus.defense})`;

        resultEl.innerHTML = diceRollResultLog;
        updatePlayerStatsUI();

        if (isATKDiceRolled) {
            startCombatAfterDiceRoll();
        }
    }

    // ==========================================
    // 5. ì¸ë²¤í† ë¦¬ ë° ì•„ì´í…œ ì‚¬ìš©
    // ==========================================
    function displayInventory() {
        gameState = 'INVENTORY';
        titleEl.textContent = 'ì¸ë²¤í† ë¦¬';
        resultEl.innerHTML = ''; 
        resultEl.style.textAlign = 'left'; 
        setUIForAction(false, false); 
        const inventoryCounts = {};
        for (const itemId of player.inventory) {
            inventoryCounts[itemId] = (inventoryCounts[itemId] || 0) + 1;
        }
        if (player.inventory.length === 0) {
            resultEl.textContent = 'ê°€ì§„ ì•„ì´í…œì´ ì—†ìŠµë‹ˆë‹¤.';
        }
        for (const itemId in inventoryCounts) {
            const item = findDataById(ALL_ITEMS, itemId);
            if (item && item.type === 'consumable') {
                const itemButton = document.createElement('button');
                itemButton.textContent = `ì‚¬ìš©: ${item.name} (x${inventoryCounts[itemId]}) - ${item.description}`;
                itemButton.onclick = () => useItem(item); 
                resultEl.appendChild(itemButton);
            }
        }
        const exitButton = document.createElement('button');
        exitButton.textContent = 'íƒí—˜ìœ¼ë¡œ ëŒì•„ê°€ê¸°';
        exitButton.className = 'exit-button';
        exitButton.onclick = () => exitInventory(); 
        resultEl.appendChild(exitButton);
    }

    function exitInventory() {
        if (player.hp <= 0) {
            loseGame(); 
        } else {
            gameState = 'EXPLORING';
            updateMainUI(currentStageData.name, 'íƒí—˜ì„ ê³„ì†í•©ë‹ˆë‹¤.', 'íƒí—˜í•˜ê¸°');
            setUIForAction(true, true); 
        }
    }

    function useItem(itemToUse) {
        const itemIndex = player.inventory.indexOf(itemToUse.id);
        if (itemIndex === -1) { alert("ì˜¤ë¥˜: í•´ë‹¹ ì•„ì´í…œì´ ì—†ìŠµë‹ˆë‹¤."); displayInventory(); return; }
        player.inventory.splice(itemIndex, 1); 
        const effect = itemToUse.effect;
        let value = 0;
        if (effect.valueDrops) {
            const drop = getWeightedRandom(effect.valueDrops);
            value = drop.amount;
        } 
        else if (effect.value) { 
            value = getRandomInt(effect.value.minValue, effect.value.maxValue);
        }
        let changeValue = 0;
        if (effect.direction === "POSITIVE") {
            changeValue = value;
        } else if (effect.direction === "NEGATIVE") {
            changeValue = -value;
        } else if (effect.direction === "RANDOM") {
            changeValue = (Math.random() < 0.5) ? value : -value;
        }
        let effectMessage = "";
        if (effect.stat === "hp") {
            player.hp += changeValue;
            if (player.hp > player.maxHp) player.hp = player.maxHp; 
            effectMessage = `HPê°€ ${changeValue}ë§Œí¼ íšŒë³µë˜ì—ˆìŠµë‹ˆë‹¤. (í˜„ì¬ HP: ${player.hp})`;
        } 
        else if (effect.stat === "str") {
            player.attack += changeValue;
            effectMessage = `ê³µê²©ë ¥(ATK)ì´ ${changeValue}ë§Œí¼ ë³€ë™í–ˆìŠµë‹ˆë‹¤. (í˜„ì¬ ATK: ${player.attack})`;
        }
        alert(effectMessage);
        updatePlayerStatsUI(); 
        displayInventory(); 
    }

    // ==========================================
    // 6. ìƒì  ê¸°ëŠ¥
    // ==========================================
    function displayShopUI() {
        titleEl.textContent = currentEvent.name; 
        resultEl.innerHTML = ''; 
        resultEl.style.textAlign = 'left'; 
        setUIForAction(false, false); 
        generateShopInventory(currentEvent); 
        for (const item of currentEvent.inventory) {
            const itemButton = document.createElement('button');
            itemButton.textContent = `êµ¬ë§¤: ${item.name} (${item.price} Gold) - ${item.description}`;
            itemButton.onclick = () => buyItem(item); 
            resultEl.appendChild(itemButton);
        }
        const exitButton = document.createElement('button');
        exitButton.textContent = 'ê°€ê²Œ ë‚˜ê°€ê¸°';
        exitButton.className = 'exit-button'; 
        exitButton.onclick = () => exitShop(); 
        resultEl.appendChild(exitButton);
    }

    function exitShop() {
        gameState = 'EXPLORING';
        currentEvent = null;
        
        // â­ ìƒì  ìŠ¤í…Œì´ì§€(idê°€ 'shop'ì¸ ê²½ìš°)ì—ì„œ ë‚˜ê°ˆ ë•Œë§Œ ë‹¤ìŒ ì§€ì—­ìœ¼ë¡œ ì´ë™ â­
        if (currentAreaID === 'shop') { 
            advanceStage(); // ë‹¤ìŒ ì§€ì—­ìœ¼ë¡œ ì´ë™
        } else {
            // ìƒì¸ì´ë²¤íŠ¸(mystery_merchant) ë“± ë‹¤ë¥¸ ì´ë²¤íŠ¸ì—ì„œ ë‚˜ê°€ëŠ” ê²½ìš°
            updateMainUI(currentStageData.name, 'íƒí—˜ì„ ê³„ì†í•©ë‹ˆë‹¤.', 'íƒí—˜í•˜ê¸°');
            setUIForAction(true, true); 
        }
    }

    function buyItem(itemToBuy) {
        if (player.gold >= itemToBuy.price) {
            player.gold -= itemToBuy.price;
            player.inventory.push(itemToBuy.id);
            updatePlayerStatsUI(); 
            alert(`${itemToBuy.name}ì„(ë¥¼) êµ¬ë§¤í–ˆìŠµë‹ˆë‹¤.`);
        } else {
            alert('ê³¨ë“œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤.');
        }
    }

    function generateShopInventory(eventData) {
        currentEvent.inventory = []; 
        let itemIDList = [];
        if (eventData.id === 'shop') {
            itemIDList = eventData.itemIds;
        } else if (eventData.id === 'mystery_merchant') {
            itemIDList = eventData.itemIds.map(item => item.itemID); 
        }
        for (const id of itemIDList) {
            const itemData = findDataById(ALL_ITEMS, id);
            if (itemData) {
                const price = getRandomInt(itemData.priceRange.minPrice, itemData.priceRange.maxPrice);
                currentEvent.inventory.push({ ...itemData, price: price });
            }
        }
    }
  </script>
  </body>
</html>


